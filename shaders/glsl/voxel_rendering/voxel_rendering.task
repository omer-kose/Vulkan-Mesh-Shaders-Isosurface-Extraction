#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_mesh_shader : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_8bit_storage : require


#include "input_structures.h"

taskPayloadSharedEXT TaskPayload taskPayload;

layout(local_size_x = 32) in;
void main()
{
	uint threadID = gl_LocalInvocationID.x;
	// In indirect dispatch workgroupID is no longer local to the chunk but global as all the blocks in all the chunks are dispatched at the same time. 
	// So, it is used to fetch the local group id which will be used to compute the firstBlockID
	uint workgroupID = gl_WorkGroupID.x; 

	ChunkDrawData drawData = chunkDrawDataBuffer.chunkDrawData[workgroupID];

	// Convert linear workgroud id (or meshlet id) into absolute x, y and z coordinates. 
    uint numBlocksX = (chunkSize.x + BLOCK_SIZE - 1) / BLOCK_SIZE;
    uint numBlocksY = (chunkSize.y + BLOCK_SIZE - 1) / BLOCK_SIZE;

    uint blockID_Z = drawData.localWorkgroupID / (numBlocksX * numBlocksY);
    uint remaining = drawData.localWorkgroupID % (numBlocksX * numBlocksY);
    uint blockID_Y = remaining / numBlocksX;
    uint blockID_X = remaining % numBlocksX;

	// index of the first voxel in the block
    uint firstVoxelID_X = blockID_X * BLOCK_SIZE;
    uint firstVoxelID_Y = blockID_Y * BLOCK_SIZE;
    uint firstVoxelID_Z = blockID_Z * BLOCK_SIZE;

	// Two loops, all lanes used
	uint count = 0;
	for (uint i = threadID; i < BLOCK_VOLUME; i += 32)
	{
        uint x = i % BLOCK_SIZE;
        uint y = (i / BLOCK_SIZE) % BLOCK_SIZE;
        uint z = i / (BLOCK_SIZE * BLOCK_SIZE);

		uvec3 voxelID = uvec3(firstVoxelID_X + x, firstVoxelID_Y + y, firstVoxelID_Z + z);

        // Skip voxels outside the grid
		if(any(greaterThanEqual(voxelID, shellSize))) continue;

		uint value = voxelValue(drawData.chunkID, voxelID); 
		bool accept = value > 0; // Voxel is accepted if occupied  
		uint payloadIndex = subgroupExclusiveAdd(uint(accept));

		if (accept)
		{
			// Output a unique meshlet ID for the mesh shader to decode (simply flattening the voxel index in (x,y,z) to a single float which can be easily converted back to voxel index)
			uint meshletID = (firstVoxelID_Z + z) * chunkSize.y * chunkSize.x + (firstVoxelID_Y + y) * chunkSize.x + (firstVoxelID_X + x);
			taskPayload.meshlets[count + payloadIndex].meshletID = meshletID;
			taskPayload.colorIndex[count + payloadIndex] = value;
			taskPayload.chunkID = drawData.chunkID;
		}

		count += subgroupAdd(uint(accept));
	}

    EmitMeshTasksEXT(count, 1, 1);
}