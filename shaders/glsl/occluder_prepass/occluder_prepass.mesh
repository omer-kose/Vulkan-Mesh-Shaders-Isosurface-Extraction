#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_mesh_shader : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "input_structures.h"

// These are also the face normals
const ivec3 neighborOffset[6] = ivec3[6](
    ivec3( 1,0,0), ivec3(-1,0,0),
    ivec3( 0,1,0), ivec3( 0,-1,0),
    ivec3( 0,0,1), ivec3( 0, 0,-1)
);

uvec3 decodeBlock(uint blockLinear, uvec3 n)
{
    uint xy = n.x * n.y;
    uint z = blockLinear / xy;
    uint remaining = blockLinear % xy;
    uint y = remaining / n.x;
    uint x = remaining % n.x;
    return uvec3(x, y, z);
}

// Generate 4 corners for a given face index (0..5) in the world space
void makeFaceCorners(int faceId, vec3 center, vec3 size, out vec3 P[4]) 
{
    vec3 h = 0.5 * size;
    switch (faceId) 
	{
    case 0: // +X
        P[0] = center + vec3( h.x, -h.y, -h.z);
        P[1] = center + vec3( h.x,  -h.y, h.z);
        P[2] = center + vec3( h.x,  h.y,  h.z);
        P[3] = center + vec3( h.x, h.y,  -h.z);
        break;
    case 1: // -X
        P[0] = center + vec3( -h.x, -h.y, -h.z);
        P[1] = center + vec3( -h.x,  -h.y, h.z);
        P[2] = center + vec3( -h.x,  h.y,  h.z);
        P[3] = center + vec3( -h.x, h.y,  -h.z);
        break;
    case 2: // +Y
        P[0] = center + vec3(-h.x,  h.y, h.z);
        P[1] = center + vec3( h.x,  h.y, h.z);
        P[2] = center + vec3( h.x,  h.y,  -h.z);
        P[3] = center + vec3(-h.x,  h.y,  -h.z);
        break;
    case 3: // -Y
        P[0] = center + vec3(-h.x,  -h.y, h.z);
        P[1] = center + vec3( h.x,  -h.y, h.z);
        P[2] = center + vec3( h.x,  -h.y,  -h.z);
        P[3] = center + vec3(-h.x,  -h.y,  -h.z);
        break;
    case 4: // +Z
        P[0] = center + vec3(-h.x, -h.y,  h.z);
        P[1] = center + vec3( h.x, -h.y,  h.z);
        P[2] = center + vec3( h.x,  h.y,  h.z);
        P[3] = center + vec3(-h.x,  h.y,  h.z);
        break;
    case 5: // -Z
        P[0] = center + vec3(-h.x, -h.y,  -h.z);
        P[1] = center + vec3( h.x, -h.y,  -h.z);
        P[2] = center + vec3( h.x,  h.y,  -h.z);
        P[3] = center + vec3(-h.x,  h.y,  -h.z);
        break;
    }
}

/*
    Each mesh shader group will render a block as a single voxel
*/ 

layout(local_size_x = 32) in;
layout(triangles, max_vertices = 12, max_primitives = 6) out;
void main()
{
    // Fetch chunk data
    const uint threadID = gl_LocalInvocationID.x;
    uint chunkID = chunkDrawDataBuffer.chunkDrawData[gl_WorkGroupID.x].chunkID;
    uint localBlockID = chunkDrawDataBuffer.chunkDrawData[gl_WorkGroupID.x].localWorkgroupID;
    vec3 lower = chunkMetadataBuffer.chunkMetadata[chunkID].lowerCornerPos;
    vec3 upper = chunkMetadataBuffer.chunkMetadata[chunkID].upperCornerPos;

    // Block's coordinates in the chunk
    const uvec3 groupsPerChunk = chunkSize / uvec3(BLOCK_SIZE);
    uvec3 b = decodeBlock(localBlockID, groupsPerChunk);

    // Block AABB
    vec3 blockStep = ((upper - lower) / vec3(chunkSize)) * float(BLOCK_SIZE);
    vec3 blockCenter = lower + vec3(b) * blockStep;

	// Decide the faces to render
	bool keep = false; // Only 6 threads will modify this on their stack
	if(threadID < 6)
	{
		vec3 blockToCamera = cameraPos - blockCenter;
		bool cameraSide = false;
		switch(threadID)
		{
			case 0: 
				cameraSide = (blockToCamera.x > 0.0); // +X
				break;
			case 1:
				cameraSide = (blockToCamera.x < 0.0); // -X
				break;
			case 2:
				cameraSide = (blockToCamera.y > 0.0); // +Y
				break;
			case 3:
				cameraSide = (blockToCamera.y < 0.0); // -Y
				break;
			case 4:
				cameraSide = (blockToCamera.z > 0.0); // +Z
				break;
			case 5:
				cameraSide = (blockToCamera.z < 0.0); // -Z
				break;
		}

        keep = cameraSide;
	}

	// Find the total number of faces to be rendered
	uint numFaces = subgroupAdd(uint(keep));

	if (threadID == 0)
	{
        SetMeshOutputsEXT(4 * numFaces, 2 * numFaces);
	}

	if(threadID < 6 && keep)
	{
		// Get the offset to write the face information with prefix-sum
		uint faceWriteOffset = subgroupExclusiveAdd(uint(keep));

        uint baseV = 4u * faceWriteOffset;
        uint baseP = 2u * faceWriteOffset;

		vec3 P[4];
        makeFaceCorners(int(threadID), blockCenter, blockStep, P);
        vec3 N = neighborOffset[threadID];

		for (uint i = 0u; i < 4u; ++i) 
		{
            gl_MeshVerticesEXT[baseV + i].gl_Position = sceneData.viewproj * vec4(P[i], 1.0);
        }

        gl_PrimitiveTriangleIndicesEXT[baseP + 0] = uvec3(baseV+0, baseV+1, baseV+2);
        gl_PrimitiveTriangleIndicesEXT[baseP + 1] = uvec3(baseV+0, baseV+2, baseV+3);
	}
}
