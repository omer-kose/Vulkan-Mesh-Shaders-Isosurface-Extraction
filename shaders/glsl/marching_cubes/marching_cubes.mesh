#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_shuffle_relative : require
#extension GL_EXT_scalar_block_layout : require

#include "input_structures.h"

struct MarchingCubesLookup
{
	uint    Indices[4];
	uint8_t Vertices[12];
	uint8_t TriangleCount;
	uint8_t VertexCount;
};

layout(set = 1, binding = 0, scalar) uniform MarchingCubesLookupTable
{
	MarchingCubesLookup marchingCubesLookupTable[256];
};

layout(location = 0) out MeshOut
{
	vec3 normal;
} meshOut[];

taskPayloadSharedEXT TaskPayload taskPayload;

// 8 intermediate corner values and normals in LDS
struct Corner
{
	vec3 normal;
	float value;
};
shared Corner corners[8];

layout(local_size_x = 32) in;
layout(triangles, max_vertices = 12, max_primitives = 5) out;
void main()
{
	const uint threadID  = gl_LocalInvocationID.x;
	const uint meshletID = taskPayload.meshlets[gl_WorkGroupID.x].meshletID;

	// Reconstruct (firstVoxelID_X, firstVoxelID_Y, firstVoxelID_Z) from MeshletID
    uint firstVoxelID_X = meshletID % GRID_X;
    uint firstVoxelID_Y = (meshletID / GRID_X) % GRID_Y;
    uint firstVoxelID_Z = meshletID / (GRID_X * GRID_Y);

	// Corner positions of the cube
	vec3 cornerPos0 = vec3(firstVoxelID_X, firstVoxelID_Y, firstVoxelID_Z) / vec3(GRID_X, GRID_Y, GRID_Z);
	vec3 cornerPos1 = cornerPos0 + vec3(1.0f / GRID_X, 1.0f / GRID_Y, 1.0f / GRID_Z);

	// First 8 lanes evaluate the field for each corner, the other 24 evaluate at offsetted positions in x, y and z so we can compute a normal at each corner from the field gradient
	vec3 pos = vec3((threadID & 1) != 0 ? cornerPos1.x : cornerPos0.x, (threadID & 2) != 0 ? cornerPos1.y : cornerPos0.y, (threadID & 4) != 0 ? cornerPos1.z : cornerPos0.z);

	const vec3 epsilon = vec3(1.0f / 16.0f) / vec3(GRID_X, GRID_Y, GRID_Z);
	uint off = threadID / 8;
	pos.x += (off == 1) ? epsilon.x : 0.0f;
	pos.y += (off == 2) ? epsilon.y : 0.0f;
	pos.z += (off == 3) ? epsilon.z : 0.0f;

	// Evaluate the field function for all 32 lanes
	float value = field(pos);

	// Grab data from other lanes so we can compute the normal by computing the difference in value in x, y and z directions.
	vec3 normal;
	normal.x = subgroupShuffleDown(value, 8);
	normal.y = subgroupShuffleDown(value, 16);
	normal.z = subgroupShuffleDown(value, 24);

	// Save intermediates to LDS. Corner positions can be computed directly from indices, so no need to put in LDS.
	if (threadID < 8)
	{
		Corner corner;
		corner.normal = normalize(value - normal);
		corner.value = value;
		corners[threadID] = corner;
	}

	// Look up the Marching Cubes index from the signs of corner nodes. Only the lowest 8 lanes are relevant here, hence the 0xFF mask.
	uvec4 ballot = subgroupBallot(value >= 0.0f);
	uint index = (ballot.x & 0xFF);

	const uint vertexCount = uint(marchingCubesLookupTable[index].VertexCount);
	const uint triangleCount = uint(marchingCubesLookupTable[index].TriangleCount);
	if (threadID == 0)
	{
        SetMeshOutputsEXT(vertexCount, triangleCount);
	}

	// Output up to 12 vertices, one lane per vertex
	if (threadID < uint(marchingCubesLookupTable[index].VertexCount))
	{
		// Look up the corner indices for this edge
		uint edge = uint(marchingCubesLookupTable[index].Vertices[threadID]);
		uint i0 = edge & 0x7;
		uint i1 = edge >> 3;

		// Corner positions
		vec3 pos0 = vec3((i0 & 1) != 0? cornerPos1.x : cornerPos0.x, (i0 & 2) != 0? cornerPos1.y : cornerPos0.y, (i0 & 4) != 0? cornerPos1.z : cornerPos0.z);
		vec3 pos1 = vec3((i1 & 1) != 0? cornerPos1.x : cornerPos0.x, (i1 & 2) != 0? cornerPos1.y : cornerPos0.y, (i1 & 4) != 0? cornerPos1.z : cornerPos0.z);

		// Interpolate position and normal
		float alpha = corners[i0].value / (corners[i0].value - corners[i1].value);
		vec3 pos    = mix(pos0, pos1, alpha);
		vec3 normal = mix(corners[i0].normal, corners[i1].normal, alpha);

		// Output final vertex
		gl_MeshVerticesEXT[threadID].gl_Position = sceneData.viewproj * vec4(pos, 1.0f);
		meshOut[threadID].normal = normal;
	}

	if (threadID < triangleCount) 
	{
		uint base = threadID * 3;    // Start index for the triangle (0, 3, 6, ...)
		uint word = base / 4;         // Which uint contains the first index
		uint shift = (base % 4) * 8;  // Bit offset within the uint (0, 8, 16, or 24)

		uint i0, i1, i2;

		// Always fetch i0 from the current uint
		i0 = (marchingCubesLookupTable[index].Indices[word] >> shift) & 0xFF;

		// Fetch i1 and i2 based on shift position
		if (shift <= 8) 
		{
			// All three indices fit in the current uint
			i1 = (marchingCubesLookupTable[index].Indices[word] >> (shift + 8)) & 0xFF;
			i2 = (marchingCubesLookupTable[index].Indices[word] >> (shift + 16)) & 0xFF;
		} 
		else if (shift == 16) 
		{
			// i0 and i1 in current uint, i2 in next uint
			i1 = (marchingCubesLookupTable[index].Indices[word] >> 24) & 0xFF;
			i2 = (marchingCubesLookupTable[index].Indices[word + 1] >> 0) & 0xFF;
		}
		else 
		{ 	
			// shift == 24
			// i0 in current uint, i1 and i2 in next uint
			i1 = (marchingCubesLookupTable[index].Indices[word + 1] >> 0) & 0xFF;
			i2 = (marchingCubesLookupTable[index].Indices[word + 1] >> 8) & 0xFF;
		}

		gl_PrimitiveTriangleIndicesEXT[threadID] = uvec3(i0, i1, i2);
	}
}