#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_mesh_shader : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

#include "input_structures.h"

taskPayloadSharedEXT TaskPayload taskPayload;

layout(local_size_x = 32) in;
void main()
{
	uint threadID = gl_LocalInvocationID.x;
	uint workgroupID = gl_WorkGroupID.x; 

	NodeDrawData drawData = nodeDrawDataBuffer.nodeDrawData[workgroupID];
	SVONodeGPU node = svoNodeGPUBuffer.nodes[drawData.nodeID];

	if(node.level == leafLevel)
	{
		// Leaf level Brick processing

		// Loop through the voxels in the block with all the threads. When BRICK_VOLUME is 8x8x8, it is 16 loops a bit too much work but preferred thread size for task shader is 32 by spec
		uint count = 0;
		bool monoColor = node.brickIndex == 0xFFFFFFFFu; // if leaf is collapsed to mono color its brick index is UINT_MAX
		uint value = monoColor ? node.colorIndex : 0;
		for (uint i = threadID; i < BRICK_VOLUME; i += 32)
		{
			uint x = i % BRICK_SIZE;
			uint y = (i / BRICK_SIZE) % BRICK_SIZE;
			uint z = i / (BRICK_SIZE * BRICK_SIZE);

			if(!monoColor)
			{
				uvec3 voxelID = uvec3(x,y,z);
				value = voxelValue(drawData.nodeID, voxelID); 
			}

			bool accept = value > 0; // Voxel is accepted if occupied  
			uint payloadIndex = subgroupExclusiveAdd(uint(accept));

			if (accept)
			{
				// Output a unique meshlet ID for the mesh shader to decode (simply flattening the voxel index in (x,y,z) to a single float which can be easily converted back to voxel index)
				uint meshletID = x + BRICK_SIZE * (y + BRICK_SIZE * z);
				taskPayload.meshlets[count + payloadIndex].meshletID = meshletID;
				taskPayload.meshlets[count + payloadIndex].colorIndex = value;
				taskPayload.nodeID = drawData.nodeID;
			}

			count += subgroupAdd(uint(accept));
		}

		EmitMeshTasksEXT(count, 1, 1);
	}
	else
	{
		// TODO: Question: Can this be parallelized over multiple non-leaves? This wastes 31 other threads
		// Non-leaf nodes don't need processing just fill in the required info with thread 0
		if(threadID == 0)
		{
			taskPayload.nodeID = drawData.nodeID;
			taskPayload.nodeColorIndex = node.colorIndex;
		    EmitMeshTasksEXT(1, 1, 1);
		}
	}
}