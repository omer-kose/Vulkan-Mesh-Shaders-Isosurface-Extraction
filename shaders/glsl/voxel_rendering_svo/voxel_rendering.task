#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_mesh_shader : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_8bit_storage : require

#include "input_structures.h"

taskPayloadSharedEXT TaskPayload taskPayload;

layout(local_size_x = 32) in;
void main()
{
	uint threadID = gl_LocalInvocationID.x;
	uint workgroupID = gl_WorkGroupID.x; 

	NodeDrawData drawData = nodeDrawDataBuffer.nodeDrawData[workgroupID];
	SVONodeGPU node = svoNodeGPUBuffer.nodes[drawData.nodeID];

	if(node.level == leafLevel)
	{
		// Leaf level Brick processing
		// index of the first voxel in the brick. Each brick is local so starting index is always is 0. The range is [0, BRICK_VOLUME - 1]
		uint firstVoxelID_X = 0;
		uint firstVoxelID_Y = 0;
		uint firstVoxelID_Z = 0;

		// Loop through the voxels in the block with all the threads. When BRICK_VOLUME is 8x8x8, it is 16 loops a bit too much work but preferred thread size for task shader is 32 by spec
		uint count = 0;
		for (uint i = threadID; i < BRICK_VOLUME; i += 32)
		{
			uint x = i % BRICK_SIZE;
			uint y = (i / BRICK_SIZE) % BRICK_SIZE;
			uint z = i / (BRICK_SIZE * BRICK_SIZE);

			uvec3 voxelID = uvec3(firstVoxelID_X + x, firstVoxelID_Y + y, firstVoxelID_Z + z);

			// Skip voxels outside the grid
			if(any(greaterThanEqual(voxelID, shellSize))) continue;

			uint value = voxelValue(drawData.nodeID, voxelID); 
			bool accept = value > 0; // Voxel is accepted if occupied  
			uint payloadIndex = subgroupExclusiveAdd(uint(accept));

			if (accept)
			{
				// Output a unique meshlet ID for the mesh shader to decode (simply flattening the voxel index in (x,y,z) to a single float which can be easily converted back to voxel index)
				uint meshletID = (firstVoxelID_Z + z) * BRICK_SIZE * BRICK_SIZE + (firstVoxelID_Y + y) * BRICK_SIZE + (firstVoxelID_X + x);
				taskPayload.meshlets[count + payloadIndex].meshletID = meshletID;
				taskPayload.meshlets[count + payloadIndex].colorIndex = value;
				taskPayload.nodeID = drawData.nodeID;
			}

			count += subgroupAdd(uint(accept));
		}

		EmitMeshTasksEXT(count, 1, 1);
	}
	else
	{
		// TODO: Question: Can this be parallelized over multiple non-leaves? This wastes 31 other threads
		// Non-leaf nodes don't need processing just fill in the required info with thread 0
		if(threadID == 0)
		{
			taskPayload.nodeID = drawData.nodeID;
			taskPayload.nodeColorIndex = node.colorIndex;
		    EmitMeshTasksEXT(1, 1, 1);
		}
	}
}