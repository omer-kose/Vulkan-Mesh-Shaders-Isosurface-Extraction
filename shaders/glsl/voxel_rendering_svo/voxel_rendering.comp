#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_ballot : require

#include "input_structures.h"

layout(set = 1, binding = 0) uniform sampler2D depthPyramid;

layout(local_size_x = 128, local_size_x = 1, local_size_z = 1) in;

bool occlusionTest(vec3 lowerCornerPos, vec3 upperCornerPos)
{
	vec3 center = (lowerCornerPos + upperCornerPos) / 2.0f;
	center = (sceneData.view * vec4(center, 1)).xyz;
	float radius = length(upperCornerPos - lowerCornerPos) / 2.0f; 
	vec4 aabb;
	bool visible = false;
    float currentDepth;
	if (projectBox(lowerCornerPos, upperCornerPos, zNear, sceneData.prevViewProj, aabb, currentDepth))
	{
		float width = (aabb.z - aabb.x) * depthPyramidWidth;
		float height = (aabb.w - aabb.y) * depthPyramidHeight;

		float level = floor(log2(max(width, height)));

		// Sampler is set up to do min reduction, so this computes the minimum depth of a 2x2 texel quad
		float sampledDepth = textureLod(depthPyramid, (aabb.xy + aabb.zw) * 0.5, level).x;
		// float currentDepth = zNear / (-center.z - radius);
		visible = currentDepth > sampledDepth;
	}

	return visible;
}

// TODO: Precompute and store frustum planes
bool frustumCullTest(vec3 bmin, vec3 bmax)
{
    // Test all 8 corners against clip space [-w, w]
    // Reject if all are outside the same plane
    vec4 corners[8] = {
        sceneData.viewproj * vec4(bmin.x, bmin.y, bmin.z, 1.0),
        sceneData.viewproj * vec4(bmax.x, bmin.y, bmin.z, 1.0),
        sceneData.viewproj * vec4(bmin.x, bmax.y, bmin.z, 1.0),
        sceneData.viewproj * vec4(bmax.x, bmax.y, bmin.z, 1.0),
        sceneData.viewproj * vec4(bmin.x, bmin.y, bmax.z, 1.0),
        sceneData.viewproj * vec4(bmax.x, bmin.y, bmax.z, 1.0),
        sceneData.viewproj * vec4(bmin.x, bmax.y, bmax.z, 1.0),
        sceneData.viewproj * vec4(bmax.x, bmax.y, bmax.z, 1.0)
    };

    for(int plane = 0; plane < 6; ++plane) 
    {
        int outsideCount = 0;
        for (int i = 0; i < 8; ++i) 
        {
            vec4 p = corners[i];
            float w = p.w;
            float v;
            if (plane == 0) v =  p.x + w; // left   (x >= -w)
            if (plane == 1) v = -p.x + w; // right  (x <= w)
            if (plane == 2) v =  p.y + w; // bottom (y >= -w)
            if (plane == 3) v = -p.y + w; // top    (y <= w)
            if (plane == 4) v =  p.z + w; // near   (z >= -w in GL)
            if (plane == 5) v = -p.z + w; // far    (z <= w in GL)
            if (v < 0) outsideCount++;
        }
        if (outsideCount == 8) return false; // completely outside
    }
    return true;
}

bool cullTest(vec3 lowerCornerPos, vec3 upperCornerPos)
{
    if(frustumCullTest(lowerCornerPos, upperCornerPos))
    {
        if(occlusionTest(lowerCornerPos, upperCornerPos))
        {
            return true;
        }
    }

    return false;
}

void main()
{
    // Flat global task index over all nodes. Each thread processes a single node
    uint gtid = gl_GlobalInvocationID.x;
    if (gtid >= numActiveNodes) return;

    uint nodeID = activeNodeIndicesBuffer.indices[gtid];
    SVONodeGPU node = svoNodeGPUBuffer.nodes[nodeID];

    // cull per node
    bool survive = cullTest(node.lowerCorner, node.upperCorner);

    // Subgroup-aggregated compaction
    uint vote   = survive ? 1u : 0u;
    uint prefix = subgroupExclusiveAdd(vote); // survivors before me in this subgroup
    uint live   = subgroupAdd(vote);          // total survivors in this subgroup

    if (live == 0u) return;

    // One atomic per subgroup to reserve a contiguous span
    uint base = 0u;
    if (subgroupElect()) 
    {
        base = atomicAdd(drawNodeCountBuffer.drawNodeCount, live);
    }
    
    // Tell everyone else in the subgroup the value
    base = subgroupBroadcastFirst(base);

    if (survive) 
    {
        uint outIndex = base + prefix;
        nodeDrawDataBuffer.chunkDrawData[outIndex].nodeID = nodeID;
    }
}